name: Release and Deploy

# æ­¤ workflow åŒ…å«å®Œæ•´çš„ CI/CD æµç¨‹
# CI: æ„å»ºäºŒè¿›åˆ¶æ–‡ä»¶å¹¶åˆ›å»º GitHub Release
# CD: è‡ªåŠ¨éƒ¨ç½²åˆ°æœåŠ¡å™¨ï¼ˆé»˜è®¤ç¦ç”¨ï¼Œæ¨èä½¿ç”¨ Webhook æ–¹å¼ï¼‰
#
# æ¨èéƒ¨ç½²æ–¹å¼ï¼š
# 1. GitHub Release åˆ›å»ºåï¼Œä¼šè‡ªåŠ¨è§¦å‘é…ç½®å¥½çš„ Webhook
# 2. æœåŠ¡å™¨ä¸Šçš„ webhook-server.py æ¥æ”¶é€šçŸ¥å¹¶è‡ªåŠ¨éƒ¨ç½²
# 3. æ— éœ€åœ¨æ­¤ workflow ä¸­é…ç½®éƒ¨ç½²é€»è¾‘
#
# å‚è€ƒæ–‡æ¡£ï¼š
# - WEBHOOK_SETUP.md: Webhook é…ç½®æŒ‡å—
# - AUTO_DEPLOY_GUIDE.md: éƒ¨ç½²æ–¹æ¡ˆå¯¹æ¯”

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release'
        required: true
        default: 'v1.0.0'

jobs:
  build:
    name: Build and Release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Get version info
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi
          BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')
          GIT_COMMIT=$(git rev-parse --short HEAD)

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
          echo "git_commit=$GIT_COMMIT" >> $GITHUB_OUTPUT

          echo "ğŸ“¦ Version: $VERSION"
          echo "â° Build Time: $BUILD_TIME"
          echo "ğŸ”– Git Commit: $GIT_COMMIT"

      - name: Build binaries
        env:
          VERSION: ${{ steps.version.outputs.version }}
          BUILD_TIME: ${{ steps.version.outputs.build_time }}
          GIT_COMMIT: ${{ steps.version.outputs.git_commit }}
        run: |
          echo "ğŸ”¨ Building binaries..."

          # Build for Linux AMD64
          GOOS=linux GOARCH=amd64 go build \
            -ldflags="-s -w -X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME} -X main.GitCommit=${GIT_COMMIT}" \
            -o simple-go-app-linux-amd64 .

          # Make binary executable
          chmod +x simple-go-app-linux-amd64

          # Show file info
          ls -lh simple-go-app-*

          echo "âœ… Build completed"

      - name: Create Release and Upload Assets
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.version }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## ğŸš€ Release ${{ steps.version.outputs.version }}

            ### ğŸ“¦ Built Artifacts
            - `simple-go-app-linux-amd64` - Linux AMD64

            ### ğŸ“ Build Info
            - **Version:** ${{ steps.version.outputs.version }}
            - **Build Time:** ${{ steps.version.outputs.build_time }}
            - **Git Commit:** ${{ steps.version.outputs.git_commit }}

            ### ğŸ“¥ Installation
            ```bash
            # Download binary
            wget https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.version }}/simple-go-app-linux-amd64

            # Make executable
            chmod +x simple-go-app-linux-amd64

            # Run
            ./simple-go-app-linux-amd64
            ```

            ### ğŸš€ Auto Deploy
            This release will be automatically deployed to configured servers via webhook.
          draft: false
          prerelease: false
          files: simple-go-app-linux-amd64

  # æ–¹æ¡ˆ 1ï¼šSSH ç›´æ¥éƒ¨ç½²ï¼ˆå¯é€‰ï¼Œé»˜è®¤ç¦ç”¨ï¼‰
  # è¦å¯ç”¨ SSH éƒ¨ç½²ï¼Œè¯·å–æ¶ˆä¸‹é¢çš„æ³¨é‡Šå¹¶é…ç½® secrets
  deploy-ssh:
    name: Deploy via SSH
    needs: build
    runs-on: ubuntu-latest
    # æ‰‹åŠ¨è§¦å‘æˆ–é…ç½®äº† SSH secrets æ—¶è¿è¡Œ
    if: |
      false &&
      github.event_name == 'push' &&
      !contains(github.ref, '-dev') &&
      !contains(github.ref, '-beta')

    steps:
      - name: Checkout deploy scripts
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          echo "ğŸ” Setting up SSH..."
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "${{ secrets.SSH_KNOWN_HOSTS }}" > ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: Deploy to servers
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          SERVERS='${{ secrets.DEPLOY_SERVERS }}'

          echo "ğŸš€ Deploying version: $VERSION"
          echo ""

          # Parse JSON and deploy to each server
          echo "$SERVERS" | jq -c '.[]' | while read server; do
            NAME=$(echo $server | jq -r '.name')
            HOST=$(echo $server | jq -r '.host')
            USER=$(echo $server | jq -r '.user')
            ENV=$(echo $server | jq -r '.environment')

            echo "ğŸ“¡ Deploying to $NAME ($HOST)..."

            # Upload deploy script
            scp -o StrictHostKeyChecking=no \
                deploy/deploy.sh \
                ${USER}@${HOST}:/tmp/deploy.sh

            # Execute deployment
            ssh -o StrictHostKeyChecking=no ${USER}@${HOST} \
                "chmod +x /tmp/deploy.sh && sudo /tmp/deploy.sh ${VERSION} ${ENV}" || {
                echo "âŒ Deployment to $NAME failed"
                exit 1
            }

            # Verify deployment
            DEPLOYED_VERSION=$(ssh -o StrictHostKeyChecking=no ${USER}@${HOST} \
                "curl -s http://localhost:8080/version | jq -r '.version'" || echo "unknown")

            if [ "$DEPLOYED_VERSION" = "${VERSION#v}" ]; then
                echo "âœ… $NAME deployed successfully (version: $DEPLOYED_VERSION)"
            else
                echo "âš ï¸  $NAME version mismatch (expected: ${VERSION#v}, got: $DEPLOYED_VERSION)"
            fi

            echo ""
          done

          echo "âœ… All deployments completed"

      - name: Send notification
        if: always()
        run: |
          # è¿™é‡Œå¯ä»¥å‘é€é€šçŸ¥åˆ° Slack/Email/etc
          echo "ğŸ“§ Deployment notification sent"
          echo "   Version: ${{ needs.build.outputs.version }}"
          echo "   Status: ${{ job.status }}"

  # æ–¹æ¡ˆ 2ï¼šè§¦å‘ Webhookï¼ˆå¯é€‰ï¼Œæ¨èä½¿ç”¨ GitHub å†…ç½® webhookï¼‰
  # æ³¨æ„ï¼šæ¨èç›´æ¥åœ¨ GitHub Settings -> Webhooks é…ç½®ï¼Œæ— éœ€æ­¤ job
  trigger-webhook:
    name: Trigger Webhook
    needs: build
    runs-on: ubuntu-latest
    # é»˜è®¤ç¦ç”¨ï¼Œæ¨èä½¿ç”¨ GitHub å†…ç½® webhook åŠŸèƒ½
    if: |
      false &&
      github.event_name == 'push' &&
      !contains(github.ref, '-dev') &&
      !contains(github.ref, '-beta')

    steps:
      - name: Trigger deployment webhook
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          WEBHOOK_URLS='${{ secrets.WEBHOOK_URLS }}'

          echo "ğŸ”” Triggering webhooks for version: $VERSION"
          echo ""

          # Parse JSON and trigger each webhook
          echo "$WEBHOOK_URLS" | jq -c '.[]' | while read webhook; do
            NAME=$(echo $webhook | jq -r '.name')
            URL=$(echo $webhook | jq -r '.url')
            SECRET=$(echo $webhook | jq -r '.secret')

            echo "ğŸ“¡ Triggering $NAME..."

            # Calculate signature
            PAYLOAD="{\"version\":\"${VERSION}\",\"timestamp\":\"$(date -u +%s)\"}"
            SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$SECRET" | sed 's/^.* //')

            # Send webhook
            RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$URL" \
                -H "Content-Type: application/json" \
                -H "X-Signature: sha256=$SIGNATURE" \
                -d "$PAYLOAD")

            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | head -n-1)

            if [ "$HTTP_CODE" = "200" ]; then
                echo "âœ… $NAME triggered successfully"
            else
                echo "âŒ $NAME failed (HTTP $HTTP_CODE): $BODY"
            fi

            echo ""
          done

          echo "âœ… All webhooks triggered"

  # æ–¹æ¡ˆ 3ï¼šé€šè¿‡ JumpServer API éƒ¨ç½²ï¼ˆå¯é€‰ï¼Œé»˜è®¤ç¦ç”¨ï¼‰
  deploy-jumpserver:
    name: Deploy via JumpServer
    needs: build
    runs-on: ubuntu-latest
    # é»˜è®¤ç¦ç”¨ï¼Œå¦‚éœ€ä½¿ç”¨è¯·ä¿®æ”¹æ¡ä»¶å¹¶é…ç½®ç›¸åº” secrets
    if: |
      false &&
      github.event_name == 'push' &&
      !contains(github.ref, '-dev') &&
      !contains(github.ref, '-beta')

    steps:
      - name: Deploy via JumpServer API
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          JUMPSERVER_URL="${{ secrets.JUMPSERVER_URL }}"
          JUMPSERVER_TOKEN="${{ secrets.JUMPSERVER_TOKEN }}"

          echo "ğŸš€ Deploying via JumpServer: $VERSION"

          # è°ƒç”¨ JumpServer API æ‰¹é‡æ‰§è¡Œå‘½ä»¤
          COMMAND="curl -sSL https://github.com/${{ github.repository }}/raw/main/deploy/deploy.sh | sudo bash -s ${VERSION} prod"

          curl -X POST "${JUMPSERVER_URL}/api/v1/ops/adhoc/" \
            -H "Authorization: Bearer ${JUMPSERVER_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "{
              \"hosts\": ${{ secrets.JUMPSERVER_HOSTS }},
              \"tasks\": [{
                \"name\": \"deploy\",
                \"action\": {
                  \"module\": \"shell\",
                  \"args\": \"${COMMAND}\"
                }
              }]
            }"

          echo "âœ… JumpServer deployment triggered"
